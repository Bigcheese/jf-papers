==============================================
D4522 ``std::atomic_object_fence(mo, T...&&)``
==============================================

:Author: Olivier Giroux
:Contact: ogiroux@nvidia.com
:Author: JF Bastien
:Contact: jfb@google.com
:Date: 2015-05-08
:URL: https://github.com/jfbastien/papers/blob/master/source/D4522.rst

.. TODO Update the URL above when this becomes an N paper.

---------
Rationale
---------

Fences allow programmers to express a conservative approximation to the precise
pair-wise relations of operations required to be ordered in the happens-before
relation. This is conservative because fences use the sequenced-before relation
to select vast extents of the program into the happens-before relation.

This is commonly desired because it is difficult for users to reason about 
operations hidden behind layers of abstraction in C++ programs. An unfortunate
consequence of this is that precise expression of ordering is not possible in 
C++ currently, which makes it easy to over-constrain the order of operations 
internal to synchronization primitives that comprise multiple atomic objects.

In existing practice, the flush primitive of OpenMP is more expressive than the 
fences of C++ in at least one sense: it can optionally restrict the ordering of 
operations to a user-specified set of memory locations. This is enough to exactly 
express the required pair-wise ordering for short lock-free algorithms. This
capability isn't only relevant in OpenMP and would benefit from integration with 
the other facets of the C++ memory model.

An example use-case for this capability is a likely implementation strategy for
N4392_'s ``std::barrier`` object. This algorithm makes ordered modifications on
the atomic sub-objects of a larger non-atomic synchronization object, but the
internal modifications need only be ordered with respect to each other, not all
surrounding objects (they are ordered separately).

.. _N4392: http://wg21.link/N4392

In one example implementation, ``std::barrier`` is coded as follows:

.. code-block:: c++

  struct barrier {
      // Some member functions elided.
      void arrive_and_wait() {
          int const myepoch = epoch.load(memory_order_relaxed);
          int const result = arrived.fetch_add(1, memory_order_acq_rel) + 1;
          if (result == expected) {
              expected = nexpected.load(memory_order_relaxed);
              arrived.store(0, memory_order_relaxed);
              // Only need to order {expected, arrived} -> {epoch}.
              epoch.store(myepoch + 1, memory_order_release);
          }
          else
              while (epoch.load(memory_order_acquire) == myepoch)
                  ;
      }
  private:
      int expected;
      atomic<int> arrived, nexpected, epoch;
  };

The release operation on the epoch atomic is likely to require the compiler to
insert a fence that has an effect that goes beyond the intended constraint,
which is to order only the operations on the barrier object. Since the barrier
object is likely to be smaller than a cache line and the library's
implementation can control its alignment using ``alignas``, then it would be
possible to compile this program without a fence in this location on
architectures that are cache-line coherent.

To concisely express the bound on the set of memory operations whose order is 
constrained, we propose to accompany ``std::atomic_thread_fence`` with an 
``object`` variant which takes a reference to the object(s) to be ordered by 
the fence.

-----------------
Proposed addition
-----------------

Under 29.2 Header ``<atomic>`` synopsis [**atomics.syn**]:

.. code-block:: c++

  namespace std {
     // 29.8, fences
     // ...
     template<class... T>
     void atomic_object_fence(memory_order, T... &&objects) noexcept;
   }

Under 29.8 Fences [**atomics.fences**], after the current
``atomic_thread_fence`` paragraph:

``template<class... T> void atomic_object_fence(memory_order, T... &&objects) noexcept;``

*Effect*: Equivalent to ``atomic_thread_fence(order)`` except that operations on
objects other than those in the variadic template arguments and their
sub-objects are *un-sequenced* with the fence.

*Note*: The compiler may omit fences entirely depending on alignment
information, may generate a dynamic test leading to a fence for under-aligned
objects, or may emit the same fence an ``atomic_thread_fence`` would.

The ``__cpp_lib_atomic_object_fence`` feature test macro should be added.

----------------------
Example implementation
----------------------

A trivially conforming implementation may implement the new overload in terms of
the existing ``std::atomic_thread_fence`` using the same memory order:

.. code-block:: c++

     template<class... T>
     void atomic_object_fence(memory_order, T... &&) noexcept {
       atomic_thread_fence(memory_order);
     }

A more advanced conforming implementation may specialize the single-object case
on architectures or micro-architectures that are cache-line coherent:

.. code-block:: c++

     #define __CACHE_LINE_SIZE // Secret (micro-)architectural value.
     template<class T>
     std::enable_if<std::is_standard_layout<T>::value &&
	            __CACHE_LINE_SIZE - alignof(T) % __CACHE_LINE_SIZE >= sizeof(T)
     >::type atomic_object_fence(memory_order, T && o) noexcept {
       asm volatile ("":"+m"(o):"m"(o)); // Code motion barrier.
     }

For multiple objects, an implementation for the same architecture may emit a
run-time check that the total footprint of all the objects fits in the span of a
single cache line.  This check may commonly be eliminated as dead code.

The above barrier example's inner-code would use the new overload as follows:

.. code-block:: c++

          if (result == expected) {
              expected = nexpected.load(memory_order_relaxed);
              arrived.store(0, memory_order_relaxed);
	      atomic_object_fence(memory_order_release, *this);
              epoch.store(myepoch + 1, memory_order_relaxed);
          }

The rewrite could also list individual members of ``barrier`` instead of
``*this``. Both rewrites would be equivalent.

A non-trivial implementation enables hardware-specific optimizations which
cannot be expressed in C++ today. If the synchronized object(s) are known to
reside in memory that's not visible to other threads of execution, then a weaker
type of fence than the hardware's global fence can be used.

A sophisticated implementation based on a virtual ISA may include a memory
barrier that is applied to a sized region of memory.  Thus it can convey to the
hardware nearly the full precision of the C++ primitive proposed here.

----------------------
Relation to D4523
----------------------

In D4523 we propose to formalize the notions of false-sharing and true-sharing 
as perceived by the implementation in relation to the placement of objects in memory.
In the expository implementation of the previous section we also showed how a cache-line
coherent architecture or micro-architecture can elide fences that only bisect
relations between objects that are in the same cache line, if provable at compile-time.
These notions interact in a virtuous way.

The example application of ``std::atomic_object_fence`` to the ``std::barrier`` object
is improved by combining these notions as follows:

.. code-block:: c++

  alignas(std::thread::hardware_true_sharing_size) /* D4523 */
  struct barrier {
      // Some member functions elided.
      void arrive_and_wait() {
          int const myepoch = epoch.load(memory_order_relaxed);
          int const result = arrived.fetch_add(1, memory_order_acq_rel) + 1;
          if (result == expected) {
              expected = nexpected.load(memory_order_relaxed);
              arrived.store(0, memory_order_relaxed);
	      atomic_object_fence(memory_order_release, *this); /* D4522 */
              epoch.store(myepoch + 1, memory_order_relaxed);
          }
          else
              while (epoch.load(memory_order_acquire) == myepoch)
                  ;
      }
  private:
      int expected;
      atomic<int> arrived, nexpected, epoch;
  };

By aligning the barrier object to the true-sharing granularity, it is significantly
more likely that the implementation will be able to elide the fence if the architecture
or micro-architecture has cache-line coherency.  Of course an implementation of the
Standard is free to ensure this by other means, we provide this example as exposition
for what user programs might do.

--------------------
Memory model example
--------------------

=========================== ===========================
T0                          T1
=========================== ===========================
``0: w = 1;``               ``4: while(!a.load(rlx));``
``1: x = 1;``               ``5: objfence(acq, a, x);``
``2: objfence(rel, a, x);`` ``6: assert(x);``
``3: a.store(1,rlx);``      ``7: assert(w);``
=========================== ===========================

The semantics of fences mean that:

``2`` synchronizes-with ``5`` because [**29.8¶2**]:
  A. ``2`` is sequenced-before ``3``,
  B. ``3`` inter-thread happens-before ``4``, and
  C. ``4`` is sequenced-before ``5``.

``1`` happens-before ``6`` because [**1.10¶13-14**]:
  A. ``1`` is sequenced-before ``2``,
  B. ``2`` synchronizes-with ``5``, and
  C. ``5`` is sequenced-before ``6``.

Therefore the program is well-defined (so far) and the ``assert(x)`` of ``6`` does not fire.

However, the *un-sequenced* semantics of the object fence also mean that:

``0``  conflicts with ``7`` because [**1.10¶23**]:
  A. ``0`` is a store to ``w``, ``7`` is a load of ``w`` and they are not both atomic, and
  B. ``0`` is not sequenced-before ``2`` and ``5`` is not sequenced-before ``7``.

Therefore the ``assert(w)`` of ``7`` makes the program undefined due to a data-race.

